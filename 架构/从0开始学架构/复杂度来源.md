#### 高性能
1. 单机复杂度，操作系统的复杂度，任务调度，资源的分配，互斥、锁
    * 进程，操作系统分配资源的最小单位
    * 线程，操作系统执行任务的最小单位
2. 集群复杂度
    * 任务分配
        - 集群中机器的任务的分配，负载均衡
        - 集群机器的管理，连接、状态
    * 任务分解
        - 系统拆分，合适的粒度
        - 系统拆分后，复杂度降低，根据不同的业务属性进行优化，互不影响，子系统间的通信会成为瓶颈
#### 高可用
1. 高可用定义，系统无中断的执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一
2. 系统的高可用本质都是通过冗余来实现
3. 计算高可用
    * 这里的计算是指业务的逻辑处理。计算有一个特点就是无论在哪台机器上计算器，同样的算法和输入数据，其产出结果都是一样的。
    * 其复杂度跟高性能类似 还是在任务的分配上
    * 相对高性能，分配算法更为复杂，需要管理主备
4. 存储高可用
    * 存储与计算相比有一个本质的区别:将数据从一台机器搬到另一台机器需要经过线路传输。这意味着在某个时间点，必然会出现数据不一致的情况
    * 除了传输延迟的问题，还有一个传输线路可用性的问题，传输线路中断、拥堵、异常，并且传输线路异常时间都比较长
    * 存储高可用的难点不在于如何备份数据，而在于如何减少或规避数据不一致对业务造成的影响。
    * 分布式领域有一个著名的CAP定理，从理论上论证了存储高可用的复杂度。存储高可用不可能同时满足”一致性、可用性、分区容错性“，最多满足其中两个，这就要求我们在架构设计是进行取舍。
5. 高可用状态决策
    * 无论是计算还是存储高可用，其基础都是”状态决策“，即系统要能够判断当前的状态是正常还是异常，如果是异常就要采取行动来保证高可用。如果状态决策本身就是有错误或偏差，那么后续的处理无论多么完美也都没有意义跟价值。在具体实践中，存在一个本质的矛盾：通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。
    * 几种常见的决策方式
        - 独裁式：存在一个独立决策主体，负责收集信息并进行决策，所有冗余的个体，都将状态上报给决策者。最主要的问题是决策者出现故障时，整个状态决策都会出现问题，如果决策者再做一套状态决策，那么就会陷入递归的死循环了。
        - 协商式：两个独立的个体交换信息，然后根据规则进行决策，最常用的协商式决策就是主备决策。难点在于两者信息交换出现问题（eg:连接中断），此时应该如何决策。这种情况适合于，系统有自我诊断能力，并且通信能力正常的情况下，一旦主备间通信中断，备机将无法做出决策，因为此时主机可能正常也可能故障，所以还需要其他方式来保障，比如多个链接，不过最终还可能会全部中断
        - 民主式：多个独立的个体通过投票的方式来进行状态决策，eg: zk 选角集群leader 时。民主决策有一个固有的缺陷，脑裂。为了解决脑裂问题，民主决策的系统一般采用”投票节点数超过系统总节点数的一半“规则，这个规则导致的问题，即当节点真的有问题下线，剩余节点不超过一半，也会导致系统不可用。
            + <font color="red">脑裂：一个集群由于故障，分裂成两个集群，两个集群间互不通信，此时两个集群会投票选出两个大脑 </font>
        
#### 可扩展性
1. 系统为了应对需求变化而提供的一种扩展能力
2. 预测变化
    * 2年法则，只预测两年内的变化，唯一不变的就是变化
3. 应对变化
    * 提炼出变化层与稳定层
    * 提炼出抽象层与实现层
    * 1 写 2 抄 3 重构
        * 不要着急系统的扩展性，不着急重构，先快速满足需求
#### 低成本、安全、规模
1. 低成本
    * 最直接的方式就是减少服务器的投入，但是与高可用、高性能相悖，取决于预算
    * 引进新技术，通过新技术来减少堆服务器，但是有学习成本
    * 创新
2. 安全
    * 功能安全，与具体的编码有关，eg:sql注入，XSS攻击、密码破解
    * 架构安全，eg: DDos
3. 规模，量变引起质变
    * 功能越来越多，导致系统复杂度指数级上升
        - 系统功能间是相互关联的，并不是孤立的
    * 数据越来越多，系统复杂度发生质变
        - mysql 数据量过多，新增索引、修改字段耗时过长，造成业务不可用，引入分库分表，会引入更多的复杂性