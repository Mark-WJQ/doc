1. 缓存主要解决的问题是提高访问效率，减小数据库的访问压力。其基本原理是将可能重复使用的数据放到内存中，一次生成多次使用，避免每次使用都去访问存储系统。
2. 缓存能够带来性能的大幅提升
3. 缓存的引入会给系统架构带来更多的复杂性
    - 缓存穿透  
    **缓存没有发挥作用，业务系统虽然去缓存中查数据但是缓存中没有数据，业务系统需要再次取存储系统查数据**
        1. 存储数据不存在
            * 可以在查询不存在的时候缓存一个默认值
        2. 缓存数据生成耗费大量时间跟资源
            * 数据存在，但是生成缓存需要大量资源跟时间，如果在访问的时候缓存正好失效了，数据库会有很大的压力
    - 缓存雪崩  
    **当缓存失效（过期）后引起性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，这个步骤耗时几十毫秒甚至上百毫秒，对于一个高并发的业务系统来说几百毫秒可能会有几百上千的请求访问。由于旧的缓存已经清除新的缓存还未生成，并且各请求之间并没有通信，无法知道其他线程在生成新的缓存，所以他们都去生成缓存，都去访问存储系统，从而对存储系统造成性能压力。这些压力又会拖慢整个系统，严重的造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃**
        1. 解决方案
            * 更新锁
                - 对缓存更新进行加锁保护，保证只有一个线程能够进行缓存更新。未能获取锁的线程要么等待锁，要么返回空值或默认值。
                - 对于分布式系统来说，需要使用分布式锁，如：zk
            * 后台更新
                - 由后台线程来更新缓存，缓存本身的有效期设置成永久，后台定时更新。
                - 特殊场景：缓存内存不够时，会踢掉一部分数据，从缓存中被踢掉到下次定时任务更新缓存的这段时间内，业务线程访问到的是空值，业务看到的现象就是数据丢了。
                    * 后台线程频繁检查，如果发现没有，就及时更新
                    * 业务线程发现没值就发送一条消息，通知后台线程更新缓存
                - 后台相比较锁机制要简单一些，同时后台线程还适合业务刚上线时的缓存预热
    - 缓存热点  
    **如果大部分甚至所用请求都命中同一份缓存，那么缓存所在的机器压力也会很大**
    1. 解决方案就是将缓存热点数据复制多分缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。
    2. 缓存副本设计有一个细节需要注意，不要设置统一的过期时间，否则会出现所有缓存副本同时失效的场景，从而导致缓存雪崩。正确做法是设置一个缓存过期时间范围，不同的缓存副本的过期时间是指定范围内的随机值。