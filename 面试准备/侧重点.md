#### 当前准备阶段的侧重点
1. 背景
   * 经过这段时间一个多月的准备，发现不能全面出击，细节太多了，应该抓重点
     * 算法与数据结构
       * 分治
       * 递归
       * 枚举
       * 动归
       * 深搜/广搜
       * 时间复杂度、空间复杂度
     * 系统设计
       * 
     * 常用中间件的系统模型
       * rpc
       * mq
       * 简单了解spark
         * rdd,data_set,dataFrame
         * 宽依赖，窄依赖
         * transform，action（触发计算）
       * mysql
         * 索引：B树，B+树
         * 事务
           * ACID
           * 锁：表变更锁(独占，共享)，表锁，行锁、间隙锁（解决幻读）
     * 项目
       * 选品
       * 平时主要关注的指标
         * 异常数量
         * qps: 价格5k,15台4核8G
         * tp99
         * 慢sql/慢服务
     * Java基础
       * jvm内存模型(JMM)
         * Java语言中用于描述多线程并发访问共享内存时的一种规范。它定义了线程与内存之间的交互方式和规则，保证了多线程在共享内存时的可见性、原子性和有序性
         * JMM规定了六种内存间的操作
           * unlock：用于释放一个被锁定的变量，从而使其他线程可以访问该变量
           * lock：用于将一个变量标识为一条线程独占的。当一个线程获取锁时，如果锁已经被占用，那么线程就会等待锁释放
           * read：从主存中读取一个变量的值
           * load：从主存中加载一个变量的值到当前线程工作内存中
           * store：将一个变量的值从当前线程的工作内存中写回到主存中
           * write：将一个变量的值写入到当前线程的工作内存中
       * 锁（重点学习aqs）
         * 状态state，维护锁状态,cas变更
         * 独占锁（exclusive）/共享锁(shared)
         * LockSupport.park()/LockSupport.unpark()
         * CLH 队列，waitStatus 标识队列节点的不同状态，上一个节点释放锁后，激活下一个节点的线程，自旋（spin）获取锁
         * Condition:类似Sychronized，主要方法：await，notify，notifyAll
           - ```java
                Lock lock = new ReLock
                lock.lock()
                Condition con = lock.condition
            ```
         * sychronized
           - monitor
           - 锁膨胀：偏向锁，轻量级锁，重量级锁
           - 对象头标识锁状态
       * 容器
         * 
       * gc